1 Основы реляционной модели и SQL

1.1 Отношение (таблица)

#############################################

Создание таблицы

CREATE TABLE book
(book_id INT PRIMARY KEY AUTO_INCREMENT,
title VARCHAR(50),
author VARCHAR(30),
price DECIMAL(8,2),
amount INT);

#############################################

Вставка записи в таблицу

INSERT INTO book (book_id, title, author, price, amount) VALUES (1, 'Мастер и Маргарита', 'Булгаков М.А.', 670.99, 3);

INSERT INTO book (book_id, title, author, price, amount) VALUES (2, 'Белая гвардия', 'Булгаков М.А.', 540.50, 5);
INSERT INTO book (book_id, title, author, price, amount) VALUES (3, 'Идиот', 'Достоевский Ф.М.', 460.00, 10);
INSERT INTO book (book_id, title, author, price, amount) VALUES (4, 'Братья Карамазовы', 'Достоевский Ф.М.', 799.01, 2);

#############################################

1.2 Выборка данных

#############################################

Выборка всех данных из таблицы

SELECT * FROM book;

#############################################

Выборка отдельных столбцов

SELECT author, title, price FROM book;

#############################################

Выборка новых столбцов и присвоение им новых имен

Select title AS Название, author AS Автор FROM book;

#############################################

Выборка данных с созданием вычисляемого столбца

Для упаковки каждой книги требуется один лист бумаги, цена которого 1 рубль 65 копеек. Посчитать стоимость упаковки для каждой книги (сколько денег потребуется, чтобы упаковать все экземпляры книги). В запросе вывести название книги, ее количество и стоимость упаковки, последний столбец назвать pack.

SELECT title, amount, 1.65*amount AS pack FROM book;

#############################################

Выборка данных, вычисляемые столбцы, математические функции

В конце года цену всех книг на складе пересчитывают – снижают ее на 30%. Написать SQL запрос, который из таблицы book выбирает названия, авторов, количества и вычисляет новые цены книг. Столбец с новой ценой назвать new_price, цену округлить до 2-х знаков после запятой.

SELECT title, author, amount, ROUND (0.7*price,2) AS new_price FROM book;

#############################################

Выборка данных, вычисляемые столбцы, логические функции

При анализе продаж книг выяснилось, что наибольшей популярностью пользуются книги Михаила Булгакова, на втором месте книги Сергея Есенина. Исходя из этого решили поднять цену книг Булгакова на 10%, а цену книг Есенина - на 5%. Написать запрос, куда включить автора, название книги и новую цену, последний столбец назвать new_price. Значение округлить до двух знаков после запятой.

SELECT author, title, ROUND(IF(author="Булгаков М.А.", price*1.1, IF(author="Есенин С.А.", price*1.05, price)),2) AS new_price FROM book;

#############################################

Выборка данных по условию

Вывести автора, название  и цены тех книг, количество которых меньше 10.

SELECT author, title, price FROM book WHERE amount < 10;

#############################################

Выборка данных, логические операции

Вывести название, автора,  цену  и количество всех книг, цена которых меньше 500 или больше 600, а стоимость всех экземпляров этих книг больше или равна 5000.

SELECT title, author, price, amount FROM book WHERE (price < 500 OR price > 600) AND price*amount >= 5000;

#############################################

Выборка данных, операторы BETWEEN, IN

Вывести название и авторов тех книг, цены которых принадлежат интервалу от 540.50 до 800 (включая границы),  а количество или 2, или 3, или 5, или 7 .

SELECT title, author FROM book WHERE (price BETWEEN 540.5 AND 800) AND amount IN (2,3,5,7);

#############################################

Выборка данных с сортировкой

Вывести  автора и название  книг, количество которых принадлежит интервалу от 2 до 14 (включая границы). Информацию  отсортировать сначала по авторам (в обратном алфавитном порядке), а затем по названиям книг (по алфавиту).

SELECT author, title FROM book WHERE amount BETWEEN 2 AND 14 ORDER BY author DESC, title;

#############################################

Выборка данных, оператор LIKE

Вывести название и автора тех книг, название которых состоит из двух и более слов, а инициалы автора содержат букву «С». Считать, что в названии слова отделяются друг от друга пробелами и не содержат знаков препинания, между фамилией автора и инициалами обязателен пробел, инициалы записываются без пробела в формате: буква, точка, буква, точка. Информацию отсортировать по названию книги в алфавитном порядке.

SELECT title, author FROM book WHERE (title LIKE "% % %") AND (author LIKE "% С.%");

#############################################

1.3 Запросы, групповые операции

#############################################

Выбор уникальных элементов столбца

Отобрать различные (уникальные) элементы столбца amount таблицы book.

SELECT DISTINCT amount FROM book;

#############################################

Выборка данных, групповые функции SUM и COUNT

Посчитать, количество различных книг и количество экземпляров книг каждого автора , хранящихся на складе.  Столбцы назвать Автор, Различных_книг и Количество_экземпляров соответственно.

SELECT author AS Автор, COUNT(amount) AS Различных_книг, SUM(amount) AS Количество_экземпляров FROM book GROUP BY author;

#############################################

Выборка данных, групповые функции MIN, MAX и AVG

Вывести фамилию и инициалы автора, минимальную, максимальную и среднюю цену книг каждого автора . Вычисляемые столбцы назвать Минимальная_цена, Максимальная_цена и Средняя_цена соответственно.

SELECT author, MIN(price) AS Минимальная_цена, MAX(price) AS Максимальная_цена, AVG(price) AS Средняя_цена FROM book GROUP BY author;

#############################################

Выборка данных c вычислением, групповые функции

Для каждого автора вычислить суммарную стоимость книг S (имя столбца Стоимость), а также вычислить налог на добавленную стоимость  для полученных сумм (имя столбца НДС ) , который включен в стоимость и составляет k = 18%,  а также стоимость книг  (Стоимость_без_НДС) без него. Значения округлить до двух знаков после запятой.

SELECT author, SUM(price*amount) AS Стоимость, ROUND(SUM(price*amount)*0.18/(1+0.18),2) AS НДС, ROUND(SUM(price*amount)/(1 + 0.18),2) AS Стоимость_без_НДС FROM book GROUP BY author;

#############################################

Вычисления по таблице целиком

Вывести  цену самой дешевой книги, цену самой дорогой и среднюю цену уникальных книг на складе. Названия столбцов Минимальная_цена, Максимальная_цена, Средняя_цена соответственно. Среднюю цену округлить до двух знаков после запятой.

SELECT MIN(price) AS Минимальная_цена, MAX(price) AS Максимальная_цена, ROUND(AVG(price),2) AS Средняя_цена FROM book;

#############################################

Выборка данных по условию, групповые функции

Вычислить среднюю цену и суммарную стоимость тех книг, количество экземпляров которых принадлежит интервалу от 5 до 14, включительно. Столбцы назвать Средняя_цена и Стоимость, значения округлить до 2-х знаков после запятой.

SELECT ROUND(AVG(price),2) AS Средняя_цена, SUM(price*amount) AS Стоимость FROM book WHERE amount BETWEEN 5 AND 14;

#############################################

Выборка данных по условию, групповые функции, WHERE и HAVING

Посчитать стоимость всех экземпляров каждого автора без учета книг «Идиот» и «Белая гвардия». В результат включить только тех авторов, у которых суммарная стоимость книг (без учета книг «Идиот» и «Белая гвардия») более 5000 руб. Вычисляемый столбец назвать Стоимость. Результат отсортировать по убыванию стоимости.

SELECT author, SUM(price*amount) AS Стоимость FROM book WHERE title NOT IN ('Идиот', 'Белая гвардия') GROUP BY author HAVING Стоимость > 5000 ORDER BY Стоимость DESC;

#############################################

1.4 Вложенные запросы

#############################################

Вложенный запрос, возвращающий одно значение

Вывести информацию (автора, название и цену) о  книгах, цены которых меньше или равны средней цене книг на складе. Информацию вывести в отсортированном по убыванию цены виде. Среднее вычислить как среднее по цене книги.

SELECT author, title, price FROM book WHERE price <= (SELECT AVG(price) FROM book) ORDER BY price DESC;

#############################################

Использование вложенного запроса в выражении

Вывести информацию (автора, название и цену) о тех книгах, цены которых превышают минимальную цену книги на складе не более чем на 150 рублей в отсортированном по возрастанию цены виде.

SELECT author, title, price FROM book WHERE price - (SELECT MIN(price) FROM book)<= 150 ORDER BY price;

#############################################

Вложенный запрос, оператор IN

Вывести информацию (автора, книгу и количество) о тех книгах, количество экземпляров которых в таблице book не дублируется.

SELECT author, title, amount FROM book WHERE amount IN (SELECT amount FROM book GROUP BY amount HAVING COUNT(amount) = 1);    

#############################################

Вложенный запрос, операторы ANY и ALL

Вывести информацию о книгах(автор, название, цена), цена которых меньше самой большой из минимальных цен, вычисленных для каждого автора.

SELECT author, title, price
FROM book
WHERE price < ANY (
        SELECT MIN(price) 
        FROM book 
        GROUP BY author 
      );

#############################################

Вложенный запрос после SELECT

Посчитать сколько и каких экземпляров книг нужно заказать поставщикам, чтобы на складе стало одинаковое количество экземпляров каждой книги, равное значению самого большего количества экземпляров одной книги на складе. Вывести название книги, ее автора, текущее количество экземпляров на складе и количество заказываемых экземпляров книг. Последнему столбцу присвоить имя Заказ. В результат не включать книги, которые заказывать не нужно.

SELECT title, author, amount, (SELECT MAX(amount) FROM book) - amount AS Заказ FROM book WHERE amount < (SELECT MAX(amount) FROM book);

#############################################

1.5 Запросы корректировки данных

#############################################

Создание пустой таблицы

Создать таблицу поставка (supply).

CREATE TABLE supply
(
    supply_id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(50),
    author VARCHAR(30),
    price DECIMAL(8, 2),
    amount INT
);

#############################################

Добавление записей в таблицу

Занесите в таблицу supply четыре записи.

INSERT INTO supply (title, author, price, amount)
VALUES
('Лирика', 'Пастернак Б.Л.', 518.99, 2),
('Черный человек', 'Есенин С.А.', 570.20, 6),
('Белая гвардия', 'Булгаков М.А.', 540.50, 7),
('Идиот', 'Достоевский Ф.М.', 360.80, 3);

#############################################

Добавление записей из другой таблицы

Добавить из таблицы supply в таблицу book, все книги, кроме книг, написанных Булгаковым М.А. и Достоевским Ф.М.

INSERT INTO book (title, author, price, amount) 
SELECT title, author, price, amount 
FROM supply WHERE author not in ('Булгаков М.А.', 'Достоевский Ф.М.') ;

#############################################

Добавление записей, вложенные запросы

Занести из таблицы supply в таблицу book только те книги, авторов которых нет в  book.

INSERT INTO book (title, author, price, amount)
SELECT title, author, price, amount
FROM supply
WHERE author NOT IN (
    SELECT author
    FROM book
);

#############################################

Запросы на обновление

Уменьшить на 10% цену тех книг в таблице book, количество которых принадлежит интервалу от 5 до 10, включая границы.

UPDATE book
SET price = 0.9 * price
WHERE amount BETWEEN 5 AND 10;

#############################################

Запросы на обновление нескольких столбцов

В таблице book необходимо скорректировать значение для покупателя в столбце buy таким образом, чтобы оно не превышало количество экземпляров книг, указанных в столбце amount. А цену тех книг, которые покупатель не заказывал, снизить на 10%.

UPDATE book
SET
buy = IF(buy > amount, amount, buy),
price = IF(buy = 0, price * 0.9, price);

#############################################

Запросы на обновление нескольких таблиц 

Для тех книг в таблице book , которые есть в таблице supply, не только увеличить их количество в таблице book ( увеличить их количество на значение столбца amount таблицы supply), но и пересчитать их цену (для каждой книги найти сумму цен из таблиц book и supply и разделить на 2).

UPDATE book, supply
SET book.amount = book.amount + supply.amount,
book.price = (book.price + supply.price)/2
WHERE book.title = supply.title AND book.author = supply.author;

#############################################

Запросы на удаление

Удалить из таблицы supply книги тех авторов, общее количество экземпляров книг которых в таблице book превышает 10.

DELETE FROM supply
WHERE author IN(
    SELECT author
    FROM book
    GROUP BY author
    HAVING SUM(amount) > 10   
);

#############################################

Запросы на создание таблицы

Создать таблицу заказ (ordering), куда включить авторов и названия тех книг, количество экземпляров которых в таблице book меньше среднего количества экземпляров книг в таблице book. В таблицу включить столбец   amount, в котором для всех книг указать одинаковое значение - среднее количество экземпляров книг в таблице book.

CREATE TABLE ordering AS
SELECT author, title,
    (
    SELECT ROUND(AVG(amount))
    FROM book
    ) AS amount
FROM book
WHERE amount < (SELECT AVG(amount) FROM book);

#############################################

Корректировка данных (вольная тема)

Обновление книг, которые участвуют в поставках
	
UPDATE book, supply
SET supply.price = book.price,
supply.amount = IF (supply.amount > book.amount, book.amount, supply.amount)
WHERE supply.title = book.title AND supply.author = book.author; 

#############################################

1.6 Таблица "Командировки", запросы на выборку

#############################################

Вывести из таблицы trip информацию о командировках тех сотрудников, фамилия которых заканчивается на букву «а», в отсортированном по убыванию даты последнего дня командировки виде. В результат включить столбцы name, city, per_diem, date_first, date_last.

SELECT name, city, per_diem, date_first, date_last
FROM trip
WHERE name LIKE '%а %'
ORDER BY date_last DESC;

#############################################

Вывести в алфавитном порядке фамилии и инициалы тех сотрудников, которые были в командировке в Москве.

SELECT DISTINCT name
FROM trip
WHERE city = 'Москва'
ORDER BY name;

#############################################

Для каждого города посчитать, сколько раз сотрудники в нем были.  Информацию вывести в отсортированном в алфавитном порядке по названию городов. Вычисляемый столбец назвать Количество. 

SELECT city,
COUNT(city) AS Количество
FROM trip
GROUP BY city
ORDER BY city;

#############################################

Оператор LIMIT

Вывести два города, в которых чаще всего были в командировках сотрудники. Вычисляемый столбец назвать Количество.

SELECT city,
COUNT(city) AS Количество
FROM trip
GROUP BY city
ORDER BY Количество DESC
LIMIT 2;

#############################################

Вывести информацию о командировках во все города кроме Москвы и Санкт-Петербурга (фамилии и инициалы сотрудников, город ,  длительность командировки в днях, при этом первый и последний день относится к периоду командировки). Последний столбец назвать Длительность. Информацию вывести в упорядоченном по убыванию длительности поездки, а потом по убыванию названий городов (в обратном алфавитном порядке).

SELECT name, city, DATEDIFF(date_last, date_first) + 1 AS Длительность
FROM trip
WHERE city NOT IN ('Москва', 'Санкт-Петербург')
ORDER BY Длительность DESC, city DESC;

#############################################

Вывести информацию о командировках сотрудника(ов), которые были самыми короткими по времени. В результат включить столбцы name, city, date_first, date_last.

SELECT name, city, date_first, date_last FROM trip WHERE DATEDIFF(date_last, date_first) = (SELECT MIN(DATEDIFF(date_last, date_first)) FROM trip);

#############################################

Вывести информацию о командировках, начало и конец которых относятся к одному месяцу (год может быть любой). В результат включить столбцы name, city, date_first, date_last. Строки отсортировать сначала  в алфавитном порядке по названию города, а затем по фамилии сотрудника .

SELECT name, city, date_first, date_last FROM trip WHERE MONTH(date_first) = MONTH(date_last) ORDER BY city, name;

#############################################

Вывести название месяца и количество командировок для каждого месяца. Считаем, что командировка относится к некоторому месяцу, если она началась в этом месяце. Информацию вывести сначала в отсортированном по убыванию количества, а потом в алфавитном порядке по названию месяца виде. Название столбцов – Месяц и Количество.

SELECT MONTHNAME(date_first) AS Месяц, COUNT(MONTHNAME(date_first)) AS Количество FROM trip GROUP BY MONTHNAME(date_first) ORDER BY Количество DESC, Месяц;

#############################################

Вывести сумму суточных (произведение количества дней командировки и размера суточных) для командировок, первый день которых пришелся на февраль или март 2020 года. Значение суточных для каждой командировки занесено в столбец per_diem. Вывести фамилию и инициалы сотрудника, город, первый день командировки и сумму суточных. Последний столбец назвать Сумма. Информацию отсортировать сначала  в алфавитном порядке по фамилиям сотрудников, а затем по убыванию суммы суточных.

SELECT name, city, date_first, (DATEDIFF(date_last, date_first) + 1) * per_diem AS Сумма FROM trip WHERE MONTH(date_first) IN (2,3) AND YEAR(date_first) = 2020 ORDER BY name, Сумма DESC;

#############################################

Вывести фамилию с инициалами и общую сумму суточных, полученных за все командировки для тех сотрудников, которые были в командировках больше чем 3 раза, в отсортированном по убыванию сумм суточных виде. Последний столбец назвать Сумма.

SELECT name, SUM((DATEDIFF(date_last, date_first) + 1) * per_diem) AS Сумма FROM trip GROUP BY name HAVING COUNT(*) > 3 ORDER BY Сумма DESC;

#############################################

1.7 Таблица "Нарушения ПДД", запросы корректировки

#############################################

Создать таблицу fine.

CREATE TABLE fine
(
    fine_id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(30),
    number_plate VARCHAR(6),
    violation VARCHAR(50),
    sum_fine DECIMAL(8,2),
    date_violation DATE,
    date_payment DATE
);

#############################################

В таблицу fine первые 5 строк уже занесены. Добавить в таблицу записи с ключевыми значениями 6, 7, 8.

INSERT INTO fine (name, number_plate, violation, date_violation) VALUES
('Баранов П.Е.','Р523ВТ','Превышение скорости(от 40 до 60)','2020-02-14'),
('Абрамова К.А.','О111АВ','Проезд на запрещающий сигнал','2020-02-23'), 
('Яковлев Г.Р.','Т330ТТ','Проезд на запрещающий сигнал','2020-03-03');

#############################################

Использование временного имени таблицы (алиаса)

Занести в таблицу fine суммы штрафов, которые должен оплатить водитель, в соответствии с данными из таблицы traffic_violation. При этом суммы заносить только в пустые поля столбца  sum_fine.

UPDATE fine AS f, traffic_violation AS tv
SET f.sum_fine = tv.sum_fine
WHERE tv.violation = f.violation AND f.sum_fine IS Null;

#############################################

Группировка данных по нескольким столбцам

Вывести фамилию, номер машины и нарушение только для тех водителей, которые на одной машине нарушили одно и то же правило   два и более раз. При этом учитывать все нарушения, независимо от того оплачены они или нет. Информацию отсортировать в алфавитном порядке, сначала по фамилии водителя, потом по номеру машины и, наконец, по нарушению.

SELECT name, number_plate, violation FROM fine GROUP BY name, number_plate, violation HAVING COUNT(violation) > 1 ORDER BY name, number_plate, violation;

#############################################

В таблице fine увеличить в два раза сумму неоплаченных штрафов для отобранных на предыдущем шаге записей. 

UPDATE fine,(
    SELECT name, number_plate, violation
    FROM fine
    GROUP BY  1, 2, 3
    HAVING COUNT(3)>=2) AS new
SET sum_fine = IF(date_payment IS NULL,sum_fine*2,sum_fine)
WHERE fine.name = new.name;

SELECT * FROM fine; -- проверить результат

#############################################

Водители оплачивают свои штрафы. В таблице payment занесены даты их оплаты.
- в таблицу fine занести дату оплаты соответствующего штрафа из таблицы payment;
- уменьшить начисленный штраф в таблице fine в два раза  (только для тех штрафов, информация о которых занесена в таблицу payment) , если оплата произведена не позднее 20 дней со дня нарушения.

UPDATE fine AS f, payment AS p   
SET f.date_payment = p.date_payment
WHERE (f.name, f.number_plate, f.violation, f.date_violation) = (p.name, p.number_plate, p.violation, p.date_violation) AND f.date_payment IS NULL;

UPDATE fine AS f, payment AS p
SET f.date_payment = p.date_payment, f.sum_fine = IF (DATEDIFF(p.date_payment, p.date_violation) < 21, f.sum_fine / 2, f.sum_fine)
WHERE (f.name, f.number_plate, f.violation, f.date_violation) = (p.name, p.number_plate, p.violation, p.date_violation);

SELECT * FROM fine;

#############################################

Создать новую таблицу back_payment, куда внести информацию о неоплаченных штрафах (Фамилию и инициалы водителя, номер машины, нарушение, сумму штрафа  и  дату нарушения) из таблицы fine.

CREATE TABLE back_payment AS
SELECT name, number_plate, violation, sum_fine, date_violation
FROM fine
WHERE date_payment IS NULL;

#############################################

Удалить из таблицы fine информацию о нарушениях, совершенных раньше 1 февраля 2020 года. 

DELETE FROM fine WHERE date_violation < '2020-02-01';

#############################################

2 Запросы SQL к связанным таблицам

2.1 Связи между таблицами

#############################################

Создать таблицу author

CREATE TABLE author
(
 author_id INT PRIMARY KEY AUTO_INCREMENT,
name_author VARCHAR(50)
);

#############################################

Заполнить таблицу author

INSERT INTO author (name_author) VALUES
('Булгаков М.А.'),
('Достоевский Ф.М.'),
('Есенин С.А.'),
('Пастернак Б.Л.');

#############################################

Перепишите запрос на создание таблицы book

CREATE TABLE book
(
book_id INT PRIMARY KEY AUTO_INCREMENT,
title VARCHAR(50),
author_id INT NOT NULL,
genre_id INT,
price DECIMAL(8,2),
amount INT,
FOREIGN KEY (author_id) REFERENCES author(author_id),
FOREIGN KEY (genre_id) REFERENCES genre(genre_id)
);

#############################################

Действия при удалении записи главной таблицы

Создать таблицу book той же структуры, что и на предыдущем шаге. Будем считать, что при удалении автора из таблицы author, должны удаляться все записи о книгах из таблицы book, написанные этим автором. А при удалении жанра из таблицы genre для соответствующей записи book установить значение Null в столбце genre_id. 

CREATE TABLE book
(
book_id INT PRIMARY KEY AUTO_INCREMENT,
title VARCHAR(50),
author_id INT NOT NULL,
genre_id INT,
price DECIMAL(8,2),
amount INT,
FOREIGN KEY (author_id) REFERENCES author(author_id) ON DELETE CASCADE,
FOREIGN KEY (genre_id) REFERENCES genre(genre_id) ON DELETE SET NULL
);

#############################################

Добавьте три последние записи (с ключевыми значениями 6, 7, 8) в таблицу book, первые 5 записей уже добавлены.

INSERT INTO book (title, author_id, genre_id, price, amount) VALUES
("Стихотворения и поэмы", 3, 2, 650.00, 15),
("Черный человек", 3, 2, 570.20, 6),
("Лирика", 4, 2, 518.99, 2);

#############################################

2.2 Запросы на выборку, соединение таблиц

Соединение INNER JOIN
Соединяет две таблицы (каждая строка одной таблицы сопоставляется с каждой строкой другой таблицы по условию)
Пример: Вывести название книг и их авторов.
SELECT title, name_author
FROM 
    author INNER JOIN book
    ON author.author_id = book.author_id;


Вывести название, жанр и цену тех книг, количество которых больше 8, в отсортированном по убыванию цены виде.

SELECT title, name_genre, price
FROM book INNER JOIN genre
ON book.genre_id = genre.genre_id
WHERE book.amount > 8
ORDER BY price DESC;

#############################################

Внешнее соединение LEFT и RIGHT OUTER JOIN
Оператор внешнего соединения LEFT OUTER JOIN  (можно использовать LEFT JOIN) соединяет две таблицы. Порядок таблиц для оператора важен, поскольку оператор не является симметричным.

Результат запроса формируется так:

1. в результат включается внутреннее соединение (INNER JOIN) первой и второй таблицы в соответствии с условием;
2. затем в результат добавляются те записи первой таблицы, которые не вошли во внутреннее соединение на шаге 1, для таких записей соответствующие поля второй таблицы заполняются значениями NULL.
Соединение RIGHT JOIN действует аналогично, только в пункте 2 первая таблица меняется на вторую и наоборот.

Пример: Вывести название всех книг каждого автора, если книг некоторых авторов в данный момент нет на складе – вместо названия книги указать Null.

SELECT name_author, title 
FROM author LEFT JOIN book
     ON author.author_id = book.author_id
ORDER BY name_author;  

Вывести все жанры, которые не представлены в книгах на складе.

SELECT name_genre
FROM genre LEFT JOIN book
ON genre.genre_id = book.genre_id
WHERE book.amount IS NULL; -- or title IS NULL;

############################################# 

Перекрестное соединение CROSS JOIN
Оператор перекрёстного соединения, или декартова произведения CROSS JOIN (в запросе вместо ключевых слов можно поставить запятую между таблицами) соединяет две таблицы. Порядок таблиц для оператора неважен, поскольку оператор является симметричным.
Результат запроса формируется так: каждая строка одной таблицы соединяется с каждой строкой другой таблицы, формируя  в результате все возможные сочетания строк двух таблиц.


Необходимо в каждом городе провести выставку книг каждого автора в течение 2020 года. Дату проведения выставки выбрать случайным образом. Создать запрос, который выведет город, автора и дату проведения выставки. Последний столбец назвать Дата. Информацию вывести, отсортировав сначала в алфавитном порядке по названиям городов, а потом по убыванию дат проведения выставок.

SELECT name_city, name_author, DATE_ADD('2020-01-01', INTERVAL FLOOR(RAND()*365) DAY) AS Дата
FROM city CROSS JOIN author 
ORDER BY name_city, Дата DESC;

#############################################

Запросы на выборку из нескольких таблиц

Вывести информацию о книгах (жанр, книга, автор), относящихся к жанру, включающему слово «роман» в отсортированном по названиям книг виде.
SELECT name_genre, title, name_author
FROM genre
INNER JOIN book ON genre.genre_id = book.genre_id
INNER JOIN author ON author.author_id = book.author_id
WHERE name_genre LIKE '%роман%'
ORDER BY title; 

#############################################

Запросы для нескольких таблиц с группировкой

Посчитать количество экземпляров  книг каждого автора из таблицы author.  Вывести тех авторов,  количество книг которых меньше 10, в отсортированном по возрастанию количества виде. Последний столбец назвать Количество.

SELECT name_author, SUM(amount) AS Количество
FROM author LEFT JOIN book
ON author.author_id = book.author_id
GROUP BY name_author
HAVING Количество < 10 OR Количество IS NULL
ORDER BY Количество;

#############################################

Запросы для нескольких таблиц со вложенными запросами

Вывести в алфавитном порядке всех авторов, которые пишут только в одном жанре. Поскольку у нас в таблицах так занесены данные, что у каждого автора книги только в одном жанре,  для этого запроса внесем изменения в таблицу book. Пусть у нас  книга Есенина «Черный человек» относится к жанру «Роман», а книга Булгакова «Белая гвардия» к «Приключениям» (эти изменения в таблицы уже внесены).

SELECT name_author
FROM author INNER JOIN book ON
author.author_id = book.author_id
INNER JOIN genre ON
genre.genre_id = book.genre_id
GROUP BY name_author
HAVING COUNT( DISTINCT(name_genre))=1
ORDER BY name_author;

#############################################

Вложенные запросы в операторах соединения

Вывести информацию о книгах (название книги, фамилию и инициалы автора, название жанра, цену и количество экземпляров книг), написанных в самых популярных жанрах, в отсортированном в алфавитном порядке по названию книг виде. Самым популярным считать жанр, общее количество экземпляров книг которого на складе максимально.

SELECT title, name_author, name_genre, price, amount
FROM author
    INNER JOIN book USING (author_id)
    INNER JOIN genre USING (genre_id)
WHERE genre.genre_id IN 
        (SELECT genre_id
        FROM book
        GROUP BY genre_id
        HAVING  SUM(amount) = (
            SELECT SUM(amount) AS sum_amount
            FROM book
            GROUP BY genre_id
            HAVING sum_amount
            LIMIT 1))
ORDER BY title;

#############################################

Операция соединение, использование USING()

 Если в таблицах supply  и book есть одинаковые книги, которые имеют равную цену,  вывести их название и автора, а также посчитать общее количество экземпляров книг в таблицах supply и book,  столбцы назвать Название, Автор  и Количество.

SELECT book.title AS Название, author.name_author AS Автор, book.amount + supply.amount AS Количество
FROM book INNER JOIN author USING (author_id)
INNER JOIN supply USING (price);

#############################################

JOIN (homework)

Вывести, сколько книг написано в каждом жанре и сколько экземпляров каждого жанра на складе.

SELECT name_genre AS Жанр, COUNT(title) AS Книги, IF(SUM(amount) > 0, SUM(amount), 0) AS Экземпляры
FROM genre LEFT JOIN book USING (genre_id)
GROUP BY name_genre;

#############################################

2.3 Запросы корректировки, соединение таблиц

Пример:

Для книг, которые уже есть на складе (в таблице book) по той же цене, что и в поставке (supply), увеличить количество на значение, указанное в поставке, а также обнулить количество этих книг в поставке.

UPDATE book 
     INNER JOIN author ON author.author_id = book.author_id
     INNER JOIN supply ON book.title = supply.title 
                         and supply.author = author.name_author
SET book.amount = book.amount + supply.amount,
    supply.amount = 0   
WHERE book.price = supply.price;

#############################################

Запросы на обновление, связанные таблицы

Для книг, которые уже есть на складе (в таблице book), но по другой цене, чем в поставке (supply),  необходимо в таблице book увеличить количество на значение, указанное в поставке,  и пересчитать цену. А в таблице  supply обнулить количество этих книг. Формула для пересчета цены: price = (p1*k1 + p2*k2)/(k1 + k2).

UPDATE book 
     INNER JOIN author ON author.author_id = book.author_id
     INNER JOIN supply ON book.title = supply.title 
                         and supply.author = author.name_author
SET book.amount = book.amount + supply.amount,
    book.price = (book.price*book.amount + supply.price*supply.amount)/(book.amount + supply.amount),		
    supply.amount = 0   
WHERE book.price <> supply.price;

#############################################

Запросы на добавление, связанные таблицы

INSERT INTO author(name_author)
SELECT supply.author
FROM author RIGHT JOIN supply ON
author.name_author = supply.author
WHERE name_author IS Null; 

#############################################

Запросы на добавление, связанные таблицы (ч.2)

Добавить новые книги из таблицы supply в таблицу book на основе сформированного выше запроса. Затем вывести для просмотра таблицу book.

INSERT INTO book(title, author_id, price, amount)
SELECT title, author_id, price, amount
FROM 
    author 
    INNER JOIN supply ON author.name_author = supply.author
WHERE amount <> 0;

#############################################

Запрос на обновление, вложенные запросы

 Занести для книги «Стихотворения и поэмы» Лермонтова жанр «Поэзия», а для книги «Остров сокровищ» Стивенсона - «Приключения». (Использовать два запроса).

UPDATE book
SET genre_id =
(
    SELECT genre_id
    FROM genre
    WHERE name_genre = 'Поэзия'
)
WHERE title = 'Стихотворения и поэмы';

UPDATE book
SET genre_id =
(
    SELECT genre_id
    FROM genre
    WHERE name_genre = 'Приключения'
)
WHERE title = 'Остров сокровищ';

#############################################

Каскадное удаление записей связанных таблиц

Удалить всех авторов и все их книги, общее количество книг которых меньше 20.

DELETE FROM author
WHERE author_id IN
(SELECT author_id
FROM book
GROUP BY author_id 
HAVING SUM(amount) < 20);

#############################################

Удаление записей главной таблицы с сохранением записей в зависимой

Удалить все жанры, к которым относится меньше 4-х книг. В таблице book для этих жанров установить значение Null.

DELETE FROM genre
WHERE genre_id IN
(
    SELECT genre_id
    FROM book
    GROUP BY genre_id
    HAVING COUNT(title) < 4
);

#############################################

Удаление записей, использование связанных таблиц

Удалить всех авторов, которые пишут в жанре "Поэзия". Из таблицы book удалить все книги этих авторов. В запросе для отбора авторов использовать полное название жанра, а не его id.

DELETE FROM author
USING author
INNER JOIN book ON
author.author_id = book.author_id
INNER JOIN genre ON
book.genre_id = genre.genre_id
WHERE name_genre = "Поэзия";

or:

DELETE FROM author 
USING author JOIN book USING(author_id)
             JOIN genre USING(genre_id)
WHERE name_genre='Поэзия';

#############################################

Творческое задание на корректировку таблиц

/*Уменьшить на 5 % цену книг Булгакова, на 3% цену книг Есенина (поиск выполнять по имени автора).
Вывести название, жанр, цену и автора книги, отсортировав результат по убыванию цены.
*/
UPDATE book
SET price = 0.95 * price
WHERE author_id =
(SELECT author_id
FROM author
WHERE name_author LIKE 'Булгаков%');

UPDATE book
SET price = 0.97 * price
WHERE author_id =
(SELECT author_id
FROM author
WHERE name_author LIKE 'Есенин%');

SELECT title, name_genre AS genre, price, name_author AS author
FROM book JOIN genre ON book.genre_id = genre.genre_id
JOIN author USING(author_id)
ORDER BY price DESC;

#############################################

База данных «Интернет-магазин книг», запросы на выборку

#############################################

Запросы на основе трех и более связанных таблиц (1)

Вывести все заказы Баранова Павла (id заказа, какие книги, по какой цене и в каком количестве он заказал) в отсортированном по номеру заказа и названиям книг виде.

SELECT buy_id, title, price, buy_book.amount
FROM book
INNER JOIN buy_book USING (book_id)
INNER JOIN buy USING (buy_id)
INNER JOIN client USING (client_id)
WHERE name_client = 'Баранов Павел'
ORDER BY buy_id, title;

#############################################

Запросы на основе трех и более связанных таблиц (2)

Посчитать, сколько раз была заказана каждая книга, для книги вывести ее автора (нужно посчитать, в каком количестве заказов фигурирует каждая книга).  Вывести фамилию и инициалы автора, название книги, последний столбец назвать Количество. Результат отсортировать сначала  по фамилиям авторов, а потом по названиям книг.

SELECT name_author, title, COUNT(buy_id) AS Количество
FROM book
JOIN author USING (author_id)
LEFT JOIN buy_book USING (book_id)
GROUP BY book.book_id
ORDER BY name_author, title;

#############################################

Запросы на основе трех и более связанных таблиц (3)

Вывести города, в которых живут клиенты, оформлявшие заказы в интернет-магазине. Указать количество заказов в каждый город, этот столбец назвать Количество. Информацию вывести по убыванию количества заказов, а затем в алфавитном порядке по названию городов.

SELECT name_city, COUNT(buy_id) AS Количество
FROM city
INNER JOIN client USING (city_id)
INNER JOIN buy USING (client_id)
GROUP BY city_id
ORDER BY Количество DESC, name_city;

#############################################

Запросы на основе трех и более связанных таблиц (4)

Вывести номера всех оплаченных заказов и даты, когда они были оплачены (оплата: step = 1).

SELECT buy_id, date_step_end
FROM step RIGHT JOIN buy_step USING (step_id)
WHERE date_step_end IS NOT NULL AND step_id = 1;

#############################################

Запросы на основе трех и более связанных таблиц (5)

Вывести информацию о каждом заказе: его номер, кто его сформировал (фамилия пользователя) и его стоимость (сумма произведений количества заказанных книг и их цены), в отсортированном по номеру заказа виде. Последний столбец назвать Стоимость.

SELECT buy_id, name_client, SUM(book.price*buy_book.amount) AS Стоимость
FROM buy_book
JOIN buy USING (buy_id)
JOIN client USING (client_id)
JOIN book USING (book_id) 
GROUP BY buy_id
ORDER BY buy_id;

#############################################

Запросы на основе трех и более связанных таблиц (6)

Вывести номера заказов (buy_id) и названия этапов,  на которых они в данный момент находятся. Если заказ доставлен –  информацию о нем не выводить. Информацию отсортировать по возрастанию buy_id.

SELECT buy_id, name_step
FROM step
JOIN buy_step USING(step_id)
WHERE date_step_beg IS NOT NULL AND date_step_end IS NULL 
ORDER BY buy_id;

#############################################

Запросы на основе трех и более связанных таблиц (7)

В таблице city для каждого города указано количество дней, за которые заказ может быть доставлен в этот город (рассматривается только этап Транспортировка). Для тех заказов, которые прошли этап транспортировки, вывести количество дней за которое заказ реально доставлен в город. А также, если заказ доставлен с опозданием, указать количество дней задержки, в противном случае вывести 0. В результат включить номер заказа (buy_id), а также вычисляемые столбцы Количество_дней и Опоздание. Информацию вывести в отсортированном по номеру заказа виде.

SELECT buy_id, DATEDIFF(date_step_end, date_step_beg) AS Количество_дней, IF(DATEDIFF(date_step_end, date_step_beg) > days_delivery, DATEDIFF(date_step_end, date_step_beg) - days_delivery, 0) AS Опоздание
FROM buy_step
JOIN buy USING (buy_id)
JOIN client USING (client_id)
JOIN city USING (city_id)
JOIN step USING (step_id)
WHERE name_step = 'Транспортировка' AND date_step_end IS NOT NULL
ORDER BY buy_id;

#############################################